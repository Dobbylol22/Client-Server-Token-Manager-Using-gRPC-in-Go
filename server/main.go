package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net"

	"google.golang.org/grpc"
	pb "gotokens.com/proto"
)

var (
	port = flag.Int("port", 50051, "The server port")
)

// server is used to implement osproj.serverr.
/* create a structure called server, such that server can implement the interface that was generated by this service PB . In service PB, we have 'TokenManagerServerver' interface.
therefore, server sides implements all the methods(Create,Read,Write,Drop) that were given.
*/
type server struct {
	manager *TokenManager
	pb.UnimplementedTokenManagerServer
}

// Create implements osproj.server'
// create function- this add func takes in the context which is named as ctx and then proto request which is named as CreateRequest. Then it needs to output a pointer to the proto response.
func (s *server) Create(ctx context.Context, in *pb.CreateRequest) (reply *pb.CreateReply, err error) {
	err = s.manager.Create(in.Id)
	if err != nil {
		return
	}
	return &pb.CreateReply{Message: "Create Success"}, nil
}

//Write implements osproj.server
// Write function- this add func takes in the context which is named as ctx and then proto request which is named as WriteRequest. Then it needs to output a pointer to the proto response.

func (s *server) Write(ctx context.Context, in *pb.WriteRequest) (reply *pb.WriteReply, err error) {
	partial, err := s.manager.Write(in.Id, in.Name, in.Low, in.Mid, in.High)
	if err != nil {
		return
	}
	return &pb.WriteReply{Partial: partial, Message: "Write Success"}, nil
}

//read implements osproj.server
// Read function- this add func takes in the context which is named as ctx and then proto request which is named as ReadRequest. Then it needs to output a pointer to the proto response.

func (s *server) Read(ctx context.Context, in *pb.ReadRequest) (reply *pb.ReadReply, err error) {
	final, err := s.manager.Read(in.Id)
	if err != nil {
		return
	}
	return &pb.ReadReply{Final: final, Message: "Read Success"}, nil
}

//drop implements osproj.server
// drop function- this add func takes in the context which is named as ctx and then proto request which is named as DropRequest. Then it needs to output a pointer to the proto response.

func (s *server) Drop(ctx context.Context, in *pb.DropRequest) (reply *pb.DropReply, err error) {
	err = s.manager.Drop(in.Id)
	if err != nil {
		return
	}
	return &pb.DropReply{Message: "Drop Success"}, nil
}

func main() {
	//setup the server inside the main function.
	flag.Parse()
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port)) //opening up a tcp listener.
	if err != nil {                                          //make sure the error is empty. If not print error.
		log.Fatalf("failed to listen: %v", err)
	}
	s := grpc.NewServer() //we can create a new server object from the library grpc.
	manager := NewTokenManager()
	//take this above created server object and use a function from our service.pb.go file.
	pb.RegisterTokenManagerServer(s, &server{manager: manager})
	log.Printf("server listening at %v", lis.Addr())
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
